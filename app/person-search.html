<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sök historisk person – Släktkort</title>
  <meta name="description" content="Sök historiska personer via öppna källor och öppna kandidatpool i Puzzle (in-memory, ingen lagring)." />

  <style>
    :root{ color-scheme: light; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 24px;
      max-width: 980px;
      margin-inline: auto;
      background: #fff;
      color: #111;
    }
    a{ color: inherit; text-decoration:none; }
    header{ margin-bottom:18px; }
    h1{ margin:0 0 6px; font-size: 26px; }
    .muted{ color:#555; margin:0; }

    .row{ display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    input{
      flex:1;
      min-width: 240px;
      padding:10px;
      border-radius:12px;
      border:1px solid #bbb;
      font:inherit;
    }
    button{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      font:inherit;
      cursor:pointer;
    }
    button.secondary{
      background:#fff;
      color:#111;
      border-color:#bbb;
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .badgeRow{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:#555;
    }
    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #e6e8eb;
      background:#fafafa;
    }
    .badge.warn{ background:#fff9ee; border-color:#ffe1a6; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

    .list{
      margin-top:18px;
      list-style:none;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .item{
      border:1px solid #eee;
      border-radius:14px;
      padding:12px;
      background:#fff;
    }
    .item h3{ margin:0 0 4px; font-size:16px; }
    .meta{ font-size:13px; color:#555; margin:2px 0; }
    .actions{ margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }

    .hint{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #e6e8eb;
      background:#fafafa;
      font-size:13px;
      color:#333;
    }
  </style>
</head>

<body>
  <header>
    <h1>Sök historisk person</h1>
    <p class="muted">Sök i öppna källor och öppna kandidatpool i Puzzle (in-memory, ingen lagring).</p>

    <div class="badgeRow" aria-label="Status">
      <span class="badge">Källa: <strong id="providerName">—</strong></span>
      <span class="badge">Visas: <strong id="countNum">—</strong></span>
      <span class="badge warn" id="capBadge" hidden>Max 150 visas – förfina din sökning</span>
    </div>

    <div class="hint">
      Tips: använd <span class="mono">+</span> som tokens: <span class="mono">Erik+Leksand+1820</span><br/>
      År används för filtrering/ranking i klienten (inte skickas som <span class="mono">+</span> till RA).
    </div>
  </header>

  <div class="row">
    <input id="q" placeholder="t.ex. Erik+Leksand+1820" autocomplete="off" />
    <button id="searchBtn" type="button">Sök</button>
    <button id="openPoolBtn" class="secondary" type="button" disabled>Öppna Puzzle (pool)</button>
    <button id="clearBtn" class="secondary" type="button">Rensa</button>
  </div>

  <ul id="results" class="list" aria-label="Sökresultat"></ul>

  <!-- RA Providers -->
  <script src="./assets/js/ra-providers.js"></script>

  <script>
    "use strict";

    const qEl = document.getElementById("q");
    const searchBtn = document.getElementById("searchBtn");
    const openPoolBtn = document.getElementById("openPoolBtn");
    const clearBtn = document.getElementById("clearBtn");

    const resultsEl = document.getElementById("results");
    const providerNameEl = document.getElementById("providerName");
    const countNumEl = document.getElementById("countNum");
    const capBadge = document.getElementById("capBadge");

    // in-memory only
    let lastCandidates = [];
    let lastProviderId = "—";

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function safeArray(v){ return Array.isArray(v) ? v : []; }
    function normalize(s){ return String(s||"").trim().toLowerCase(); }

    function candidateYears(c){
      const by = Number.isFinite(Number(c.birthYear)) ? c.birthYear : "—";
      const dy = Number.isFinite(Number(c.deathYear)) ? c.deathYear : "—";
      if(by==="—" && dy==="—") return "";
      return " (" + by + "–" + dy + ")";
    }

    function setProvider(id){
      lastProviderId = id || "—";
      providerNameEl.textContent = lastProviderId;
    }
    function setCount(n){
      countNumEl.textContent = Number.isFinite(Number(n)) ? String(n) : "—";
    }
    function showCapWarning(show){
      capBadge.hidden = !show;
    }

    function showMessage(text){
      resultsEl.innerHTML = "<li class='item'><div class='meta'>" + escapeHtml(text) + "</div></li>";
      setCount(0);
      openPoolBtn.disabled = true;
      lastCandidates = [];
    }

    // ---------- Encode single candidate (fallback) ----------
    function base64ToBase64Url(b64){
      return b64.replaceAll("+","-").replaceAll("/","_").replaceAll("=","");
    }
    function encodeCandidateForUrl(candidate){
      const json = JSON.stringify(candidate);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return base64ToBase64Url(b64);
    }
    function openInPuzzleSingle(candidate){
      const payload = encodeCandidateForUrl(candidate);
      window.location.href = "./person-puzzle.html?candidate=" + encodeURIComponent(payload);
    }

    // ---------- Pool -> Puzzle (postMessage, in-memory) ----------
    function openPuzzleWithPool(candidates){
      const items = safeArray(candidates).slice(0, 150);
      if(!items.length){
        alert("Inga kandidater att skicka till Puzzle.");
        return;
      }
      const w = window.open("./person-puzzle.html", "_blank", "noopener,noreferrer");
      if(!w){
        alert("Popup blockerad. Tillåt popup för att öppna Puzzle i pool-läge.");
        return;
      }

      const CHUNK = 50;
      const total = items.length;

      function sendAll(){
        for(let i=0; i<total; i+=CHUNK){
          const slice = items.slice(i, i + CHUNK);
          try{
            w.postMessage({ type:"PUZZLE_POOL", items: slice, total, offset: i }, "*");
          }catch{}
        }
      }

      sendAll();
      setTimeout(sendAll, 300);
      setTimeout(sendAll, 900);
    }

    // ---------- Token parsing ( + ) ----------
    function parseTokens(raw){
      const s = String(raw||"").trim();
      if(!s) return { nameQuery:"", tokens:[], years:[] };

      const parts = s.split("+").map(x => x.trim()).filter(Boolean);

      const years = [];
      const tokens = [];

      for(const p of parts){
        const n = Number(p);
        const isYear = Number.isFinite(n) && String(Math.trunc(n)).length >= 3 && n > 500 && n < 2500;
        if(isYear) years.push(Math.trunc(n));
        else tokens.push(p);
      }

      const nameQuery = tokens.join(" ").replace(/\s+/g, " ").trim();
      return { nameQuery, tokens, years };
    }

    // ---------- Client filter + ranking ----------
    function yearClose(y, target, range){
      if(y == null) return false;
      return Math.abs(Number(y) - target) <= range;
    }

    function scoreCandidateClient(c, parsed){
      let s = 0;
      const name = normalize(c.name);
      const place = normalize(c.place);
      const by = Number.isFinite(Number(c.birthYear)) ? Number(c.birthYear) : null;
      const dy = Number.isFinite(Number(c.deathYear)) ? Number(c.deathYear) : null;

      for(const t of parsed.tokens){
        const tt = normalize(t);
        if(!tt) continue;
        if(name.includes(tt)) s += 30;
        else if(place.includes(tt)) s += 20;
      }

      // år = bara signal. Om år finns men kandidat saknar år → liten minus (för att sortera ner)
      if(parsed.years.length){
        if(by == null && dy == null) s -= 5;
        for(const y of parsed.years){
          if(yearClose(by, y, 5)) s += 25;
          if(yearClose(dy, y, 5)) s += 15;
        }
      }

      if(c.url) s += 5;
      return s;
    }

    function filterAndRank(items, parsed){
      const arr = safeArray(items);

      // fail-closed: kräver minst 3 tecken i nameQuery (inte bara år)
      if(!parsed.nameQuery || parsed.nameQuery.length < 3) return [];

      // Om användaren gav år: filtrera inte bort allt, men prioritera kandidater med år nära.
      // (Vi behåller även kandidater utan år, men de hamnar längre ned via score)
      const scored = arr.map(c => ({ c, s: scoreCandidateClient(c, parsed) }));
      scored.sort((a,b) => b.s - a.s);

      // dedup (id först, annars name+years)
      const out = [];
      const seen = new Set();
      for(const x of scored){
        const c = x.c;
        const key = String(c.id || "") || (normalize(c.name) + "|" + String(c.birthYear||"") + "|" + String(c.deathYear||""));
        if(!key) continue;
        if(seen.has(key)) continue;
        seen.add(key);
        out.push(c);
        if(out.length >= 150) break;
      }
      return out;
    }

    function renderList(items){
      resultsEl.innerHTML = "";
      const arr = safeArray(items);

      if(!arr.length){
        showMessage("Inga träffar (eller källa blockerades av CORS/timeout).");
        return;
      }

      setCount(arr.length);
      showCapWarning(arr.length >= 150);

      openPoolBtn.disabled = false;

      for(const c of arr){
        const li = document.createElement("li");
        li.className = "item";

        li.innerHTML =
          "<h3>" + escapeHtml((c.name || "(namn saknas)") + candidateYears(c)) + "</h3>" +
          "<div class='meta'>Plats: " + escapeHtml(c.place || "—") + "</div>" +
          "<div class='meta'>Källa: " + escapeHtml(c.source || "—") + "</div>" +
          (c.url ? ("<div class='meta'>URL: <span class='mono'>" + escapeHtml(c.url) + "</span></div>") : "");

        const actions = document.createElement("div");
        actions.className = "actions";

        const poolBtn = document.createElement("button");
        poolBtn.className = "secondary";
        poolBtn.textContent = "Öppna i Puzzle (pool)";
        poolBtn.addEventListener("click", () => openPuzzleWithPool(lastCandidates));

        const singleBtn = document.createElement("button");
        singleBtn.className = "secondary";
        singleBtn.textContent = "Öppna i Puzzle (1)";
        singleBtn.addEventListener("click", () => openInPuzzleSingle(c));

        actions.appendChild(poolBtn);
        actions.appendChild(singleBtn);

        li.appendChild(actions);
        resultsEl.appendChild(li);
      }
    }

    async function runSearch(){
      showCapWarning(false);
      openPoolBtn.disabled = true;
      setProvider("—");
      setCount("—");
      resultsEl.innerHTML = "";
      lastCandidates = [];

      const raw = qEl.value.trim();
      if(raw.length < 3){
        showMessage("Skriv minst 3 tecken.");
        return;
      }

      if(!window.RAProviders || typeof window.RAProviders.pickProvider !== "function"){
        showMessage("RAProviders saknas. Kontrollera att ./assets/js/ra-providers.js finns och laddas.");
        return;
      }

      const parsed = parseTokens(raw);
      const qForProvider = parsed.nameQuery;

      if(!qForProvider || qForProvider.length < 3){
        showMessage("Skriv minst ett namn-token (t.ex. Erik+Leksand). År ensam räcker inte (fail-closed).");
        return;
      }

      let provider = null;
      try{ provider = window.RAProviders.pickProvider("auto"); }catch{ provider = null; }
      if(!provider || typeof provider.search !== "function"){
        showMessage("Ingen giltig provider hittades (auto). Kontrollera ra-providers.js.");
        return;
      }

      searchBtn.disabled = true;
      const prevText = searchBtn.textContent;
      searchBtn.textContent = "Söker…";

      let items = [];
      let used = provider.id || "auto";

      try{
        items = await provider.search(qForProvider);
      }catch{
        items = [];
      }

      // demo fallback om upstream strular
      if(!safeArray(items).length){
        try{
          const demo = window.RAProviders.pickProvider("demo");
          if(demo && typeof demo.search === "function"){
            used = demo.id || used;
            items = await demo.search(qForProvider);
          }
        }catch{
          items = [];
        }
      }

      searchBtn.disabled = false;
      searchBtn.textContent = prevText || "Sök";

      setProvider(used);

      // klient-filter + ranking (tokens + år)
      const ranked = filterAndRank(items, parsed);

      lastCandidates = ranked;
      renderList(lastCandidates);
    }

    searchBtn.addEventListener("click", runSearch);
    qEl.addEventListener("keydown", e => {
      if(e.key === "Enter"){
        e.preventDefault();
        runSearch();
      }
    });

    openPoolBtn.addEventListener("click", () => openPuzzleWithPool(lastCandidates));

    clearBtn.addEventListener("click", () => {
      qEl.value = "";
      lastCandidates = [];
      setProvider("—");
      setCount("—");
      showCapWarning(false);
      openPoolBtn.disabled = true;
      resultsEl.innerHTML = "";
      qEl.focus();
    });

    // init
    setProvider("—");
    setCount("—");
  </script>
</body>
</html>
