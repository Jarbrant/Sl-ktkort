<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sök historisk person – Släktkort</title>
  <meta name="description" content="Sök historiska personer via öppna källor och öppna kandidatpool i Puzzle (in-memory, ingen lagring)." />

  <style>
    :root{ color-scheme: light; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 24px;
      max-width: 980px;
      margin-inline: auto;
      background: #fff;
      color: #111;
    }
    a{ color: inherit; text-decoration:none; }
    header{ margin-bottom:18px; }
    h1{ margin:0 0 6px; font-size: 26px; }
    .muted{ color:#555; margin:0; }

    .row{ display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    input{
      flex:1;
      min-width: 240px;
      padding:10px;
      border-radius:12px;
      border:1px solid #bbb;
      font:inherit;
    }
    button{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #333;
      background:#111;
      color:#fff;
      font:inherit;
      cursor:pointer;
    }
    button.secondary{
      background:#fff;
      color:#111;
      border-color:#bbb;
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .badgeRow{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:#555;
    }
    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #e6e8eb;
      background:#fafafa;
    }
    .badge.ok{ background:#f5fff5; border-color:#cfe8cf; }
    .badge.warn{ background:#fff9ee; border-color:#ffe1a6; }
    .badge.err{ background:#fff2f2; border-color:#ffb3b3; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

    .list{
      margin-top:18px;
      list-style:none;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .item{
      border:1px solid #eee;
      border-radius:14px;
      padding:12px;
      background:#fff;
    }
    .item h3{ margin:0 0 4px; font-size:16px; }
    .meta{ font-size:13px; color:#555; margin:2px 0; }
    .actions{ margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }

    .hint{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #e6e8eb;
      background:#fafafa;
      font-size:13px;
      color:#333;
    }
  </style>
</head>

<body>
  <header>
    <h1>Sök historisk person</h1>
    <p class="muted">Sök i öppna källor och öppna kandidatpool i Puzzle (in-memory, ingen lagring).</p>

    <div class="badgeRow" aria-label="Status">
      <span class="badge">Källa: <strong id="providerName">—</strong></span>
      <span class="badge">Träffar: <strong id="countNum">—</strong></span>
      <span class="badge warn" id="capBadge" hidden>Max 150 visas – förfina din sökning</span>
      <span class="badge" id="loadBadge">RAProviders: <strong id="loadState">—</strong></span>
    </div>

    <div class="hint">
      Tips: använd <span class="mono">+</span> som tokens (för sortering): <span class="mono">Erik+Leksand+1820</span><br/>
      Viktigt: vi skickar inte <span class="mono">+</span> till RA – vi gör tokens i klienten (fail-closed).
    </div>
  </header>

  <div class="row">
    <input id="q" placeholder="t.ex. Erik+Leksand+1820" autocomplete="off" />
    <button id="searchBtn" type="button">Sök</button>
    <button id="openPoolBtn" class="secondary" type="button" disabled>Öppna Puzzle (pool)</button>
    <button id="clearBtn" class="secondary" type="button">Rensa</button>
  </div>

  <ul id="results" class="list" aria-label="Sökresultat"></ul>

  <!-- RA Providers -->
  <script src="./assets/js/ra-providers.js"></script>

  <script>
    "use strict";

    // =====================================================
    // PATCH NOTES (BUGFIX / QA)
    // - CAP-badge styrs av RAW COUNT (före trim), inte ranked.length.
    // - Provider-guard: om auto-provider saknas/fel -> tydligt fel (fail-closed).
    // - loadState uppdateras även vid runtime-fel (SAKNAS/ERROR).
    // - Minimikrav: minst 3 tecken + nameQuery minst 3 (enligt tidigare lås).
    // - Inga nya storage-keys. Ingen UX-redesign.
    // =====================================================

    const qEl = document.getElementById("q");
    const searchBtn = document.getElementById("searchBtn");
    const openPoolBtn = document.getElementById("openPoolBtn");
    const clearBtn = document.getElementById("clearBtn");

    const resultsEl = document.getElementById("results");

    const providerNameEl = document.getElementById("providerName");
    const countNumEl = document.getElementById("countNum");
    const capBadge = document.getElementById("capBadge");
    const loadStateEl = document.getElementById("loadState");

    let lastCandidates = [];
    let lastProviderId = "—";
    let lastRawCount = 0; // <-- RAW count från provider, innan rank/trim

    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function safeArray(v){ return Array.isArray(v) ? v : []; }
    function normalize(s){ return String(s||"").trim().toLowerCase(); }

    function candidateYears(c){
      const by = Number.isFinite(Number(c.birthYear)) ? c.birthYear : "—";
      const dy = Number.isFinite(Number(c.deathYear)) ? c.deathYear : "—";
      if(by==="—" && dy==="—") return "";
      return " (" + by + "–" + dy + ")";
    }

    function setProvider(id){
      lastProviderId = id || "—";
      providerNameEl.textContent = lastProviderId;
    }

    function setCount(n){
      countNumEl.textContent = Number.isFinite(Number(n)) ? String(n) : "—";
    }

    function showCapWarning(show){
      capBadge.hidden = !show;
    }

    function setLoadState(text){
      loadStateEl.textContent = text || "—";
    }

    function showMessage(text, kind){
      resultsEl.innerHTML =
        "<li class='item'><div class='meta'>" + escapeHtml(text) + "</div></li>";
      setCount(kind === "empty" ? 0 : "—");
    }

    // ---------- Encode single candidate (fallback) ----------
    function base64ToBase64Url(b64){
      return b64.replaceAll("+","-").replaceAll("/","_").replaceAll("=","");
    }
    function encodeCandidateForUrl(candidate){
      const json = JSON.stringify(candidate);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return base64ToBase64Url(b64);
    }
    function openInPuzzleSingle(candidate){
      const payload = encodeCandidateForUrl(candidate);
      window.location.href = "./person-puzzle.html?candidate=" + encodeURIComponent(payload);
    }

    // ---------- Pool -> Puzzle (postMessage, in-memory) ----------
    function openPuzzleWithPool(candidates){
      const items = safeArray(candidates).slice(0, 150);
      if(!items.length){
        alert("Inga kandidater att skicka till Puzzle.");
        return;
      }
      const w = window.open("./person-puzzle.html", "_blank", "noopener,noreferrer");
      if(!w){
        alert("Popup blockerad. Tillåt popup för att öppna Puzzle i pool-läge.");
        return;
      }

      const CHUNK = 50;
      const total = items.length;

      function sendAll(){
        for(let i=0; i<total; i+=CHUNK){
          const slice = items.slice(i, i + CHUNK);
          try{
            w.postMessage({ type:"PUZZLE_POOL", items: slice, total, offset: i }, "*");
          }catch{}
        }
      }

      // fail-soft: vissa browsers/blank-tabs behöver flera försök
      sendAll();
      setTimeout(sendAll, 300);
      setTimeout(sendAll, 900);
    }

    // ---------- Token parsing + client-side ranking ----------
    function parseTokens(raw){
      const s = String(raw||"").trim();
      if(!s) return { nameQuery:"", tokens:[], years:[] };

      // split +, but do NOT send '+' to RA
      const parts = s.split("+").map(x => x.trim()).filter(Boolean);

      const years = [];
      const tokens = [];

      for(const p of parts){
        const n = Number(p);
        const isYear = Number.isFinite(n) && String(Math.trunc(n)).length >= 3 && n > 500 && n < 2500;
        if(isYear) years.push(Math.trunc(n));
        else tokens.push(p);
      }

      // nameQuery: tokens without years, joined by space (RA-friendly)
      const nameQuery = tokens.join(" ").replace(/\s+/g, " ").trim();

      return { nameQuery, tokens, years };
    }

    function scoreCandidateClient(c, parsed){
      // enkel, deterministisk, fail-closed sortering
      // (inte “sanningen”, bara ranking)
      let s = 0;
      const name = normalize(c.name);
      const place = normalize(c.place);
      const by = Number.isFinite(Number(c.birthYear)) ? Number(c.birthYear) : null;
      const dy = Number.isFinite(Number(c.deathYear)) ? Number(c.deathYear) : null;

      for(const t of parsed.tokens){
        const tt = normalize(t);
        if(!tt) continue;
        if(name.includes(tt)) s += 30;
        else if(place.includes(tt)) s += 20;
      }

      for(const y of parsed.years){
        if(by !== null && Math.abs(by - y) <= 5) s += 25;
        if(dy !== null && Math.abs(dy - y) <= 5) s += 15;
      }

      if(c.url) s += 5;
      return s;
    }

    function rankAndTrim(items, parsed){
      const arr = safeArray(items);

      // fail-closed: kräver en riktig nameQuery (inte bara år)
      if(!parsed.nameQuery || parsed.nameQuery.length < 3){
        return [];
      }

      const scored = arr.map(c => ({ c, s: scoreCandidateClient(c, parsed) }));
      scored.sort((a,b) => b.s - a.s);

      // behåll max 150
      return scored.slice(0, 150).map(x => x.c);
    }

    function renderList(items){
      resultsEl.innerHTML = "";
      const arr = safeArray(items);

      if(!arr.length){
        showMessage("Inga träffar (eller källa blockerades av CORS/timeout).", "empty");
        openPoolBtn.disabled = true;
        return;
      }

      setCount(arr.length);

      // ✅ CAP: visa varning om råa träffar nådde cap (eller över)
      showCapWarning(Number(lastRawCount) >= 150);

      openPoolBtn.disabled = false;

      for(const c of arr){
        const li = document.createElement("li");
        li.className = "item";

        li.innerHTML =
          "<h3>" + escapeHtml((c.name || "(namn saknas)") + candidateYears(c)) + "</h3>" +
          "<div class='meta'>Plats: " + escapeHtml(c.place || "—") + "</div>" +
          "<div class='meta'>Källa: " + escapeHtml(c.source || "—") + "</div>" +
          (c.url ? ("<div class='meta'>URL: <span class='mono'>" + escapeHtml(c.url) + "</span></div>") : "");

        const actions = document.createElement("div");
        actions.className = "actions";

        // OBS: Behåller per-rad pool-knapp (ingen redesign). Vill du ta bort den gör vi separat AO.
        const poolBtn = document.createElement("button");
        poolBtn.className = "secondary";
        poolBtn.textContent = "Öppna i Puzzle (pool)";
        poolBtn.addEventListener("click", () => openPuzzleWithPool(lastCandidates));

        const singleBtn = document.createElement("button");
        singleBtn.className = "secondary";
        singleBtn.textContent = "Öppna i Puzzle (1)";
        singleBtn.addEventListener("click", () => openInPuzzleSingle(c));

        actions.appendChild(poolBtn);
        actions.appendChild(singleBtn);

        li.appendChild(actions);
        resultsEl.appendChild(li);
      }
    }

    function providerOk(p){
      return !!p && typeof p.search === "function" && typeof p.id === "string" && p.id.length > 0;
    }

    async function runSearch(){
      // reset UI
      showCapWarning(false);
      openPoolBtn.disabled = true;
      setProvider("—");
      setCount("—");
      lastCandidates = [];
      lastRawCount = 0;
      resultsEl.innerHTML = "";

      const raw = qEl.value.trim();

      // ✅ Minimikrav (lås): minst 3 tecken
      if(raw.length < 3){
        showMessage("Skriv minst 3 tecken.", "empty");
        return;
      }

      // ✅ RAProviders måste finnas
      if(!window.RAProviders || typeof window.RAProviders.pickProvider !== "function"){
        setLoadState("SAKNAS");
        showMessage("RAProviders saknas. Kontrollera att /app/assets/js/ra-providers.js finns och laddas.", "empty");
        return;
      }

      // RAProviders finns -> OK (för stunden)
      setLoadState("OK");

      const parsed = parseTokens(raw);

      // ✅ Viktigt: skicka RA-vänlig fråga utan '+'
      const qForProvider = parsed.nameQuery;

      // ✅ fail-closed: kräver minst ett namn-token (min 3 tecken totalt i nameQuery)
      if(!qForProvider || qForProvider.length < 3){
        showMessage("Skriv minst ett namn-token (t.ex. Erik+Leksand). År ensam räcker inte (fail-closed).", "empty");
        return;
      }

      // Auto-provider
      let provider = null;
      try{
        provider = window.RAProviders.pickProvider("auto");
      }catch{
        provider = null;
      }

      // ✅ Provider-guard
      if(!provider || typeof provider.search !== "function"){
        setLoadState("ERROR");
        showMessage("Ingen giltig provider hittades (auto). Kontrollera ra-providers.js (pickProvider/search).", "empty");
        return;
      }

      searchBtn.disabled = true;
      const prevText = searchBtn.textContent;
      searchBtn.textContent = "Söker…";

      let items = [];
      let used = provider.id || "auto";

      // 1) Försök auto (RA/Worker)
      try{
        items = await provider.search(qForProvider);
      }catch{
        items = [];
      }

      // 2) Fallback demo om tomt (enligt din spec)
      if(!safeArray(items).length){
        try{
          const demo = window.RAProviders.pickProvider("demo");
          if(demo && typeof demo.search === "function"){
            used = (demo && demo.id) ? demo.id : used;
            items = await demo.search(qForProvider);
          }
        }catch{
          items = [];
        }
      }

      // restore UI
      searchBtn.disabled = false;
      searchBtn.textContent = prevText || "Sök";

      setProvider(used);

      // ✅ Spara rawCount före trim för korrekt cap-varning
      lastRawCount = safeArray(items).length;

      // ✅ Klient-sortering med tokens (+ år) och trim till max 150
      const ranked = rankAndTrim(items, parsed);

      lastCandidates = ranked;
      renderList(lastCandidates);
    }

    // EVENTS
    searchBtn.addEventListener("click", runSearch);
    qEl.addEventListener("keydown", e => {
      if(e.key === "Enter"){
        e.preventDefault();
        runSearch();
      }
    });

    openPoolBtn.addEventListener("click", () => openPuzzleWithPool(lastCandidates));

    clearBtn.addEventListener("click", () => {
      qEl.value = "";
      lastCandidates = [];
      lastRawCount = 0;
      setProvider("—");
      setCount("—");
      showCapWarning(false);
      openPoolBtn.disabled = true;
      resultsEl.innerHTML = "";
      // återställ loadState baserat på aktuell runtime
      try{
        if(window.RAProviders && typeof window.RAProviders.pickProvider === "function"){
          setLoadState("OK");
        }else{
          setLoadState("SAKNAS");
        }
      }catch{
        setLoadState("SAKNAS");
      }
      qEl.focus();
    });

    // INIT
    (function init(){
      try{
        if(window.RAProviders && typeof window.RAProviders.pickProvider === "function"){
          setLoadState("OK");
        }else{
          setLoadState("SAKNAS");
        }
      }catch{
        setLoadState("SAKNAS");
      }
      setProvider("—");
      setCount("—");
    })();
  </script>
</body>
</html>
